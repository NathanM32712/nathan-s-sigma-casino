<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Plinko Remake</title>
  <style>
    body { font-family: sans-serif; text-align: center; background: #111; color: #eee; }
    canvas { background: #222; display: block; margin: 20px auto; border: 2px solid #555; }
    input, button { font-size: 1.2em; margin: 10px; padding: 5px 10px; }
    #balance { margin-top: 10px; font-size: 1.2em; }
  </style>
</head>
<body>
  <h1>ðŸŽ¯ Plinko</h1>
  <canvas id="plinkoCanvas" width="800" height="600"></canvas>
  <div>
    <input id="betInput" type="number" placeholder="Enter bet" />
    <button id="dropBtn">Drop Ball</button>
    <button id="backBtn">Back</button>
  </div>
  <div id="balance"></div>

  <script>
    const canvas = document.getElementById('plinkoCanvas');
    const ctx = canvas.getContext('2d');
    const SLOT_COUNT = 11;
    const BALL_R = 10;
    const gravity = 0.25;
    const pegRows = 12;
    const pegSpacing = 40;
    const pegs = [];
    let balls = [];

    const BALANCE_KEY = 'casino_balance';
    function getBalance() {
      return parseFloat(localStorage.getItem(BALANCE_KEY) || '1000');
    }
    function updateBalance(amount) {
      const newBalance = getBalance() + amount;
      localStorage.setItem(BALANCE_KEY, newBalance.toFixed(2));
      document.getElementById('balance').textContent = `Balance: $${newBalance.toFixed(2)}`;
    }

    const MULTIPLIERS = Array.from({ length: SLOT_COUNT }, (_, i) => {
      const center = (SLOT_COUNT - 1) / 2;
      const distance = Math.abs(i - center);
      return parseFloat((0.2 + (distance / center) * (10 - 0.2)).toFixed(1));
    });

    function setupPegs() {
      pegs.length = 0;
      const baseY = 80;
      for (let row = 1; row < pegRows; row++) {
        for (let col = 0; col <= row; col++) {
          const x = canvas.width / 2 + (col - row / 2) * pegSpacing;
          const y = baseY + row * pegSpacing;
          pegs.push({ x, y });
        }
      }
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const startX = canvas.width / 2 - ((SLOT_COUNT - 1) * pegSpacing) / 2;

      for (let i = 0; i < SLOT_COUNT; i++) {
        const x = startX + i * pegSpacing;
        ctx.fillStyle = '#333';
        ctx.fillRect(x - 15, canvas.height - 40, 30, 30);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(x - 15, canvas.height - 40, 30, 30);
        ctx.fillStyle = '#fff';
        ctx.fillText(`${MULTIPLIERS[i]}Ã—`, x - 10, canvas.height - 20);

        if (i < SLOT_COUNT - 1) {
          const dividerX = x + pegSpacing / 2;
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(dividerX, canvas.height - 40);
          ctx.lineTo(dividerX, canvas.height);
          ctx.stroke();
        }
      }

      pegs.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#888';
        ctx.fill();
      });

      balls.forEach(ball => {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI * 2);
        ctx.fillStyle = '#f00';
        ctx.fill();
      });
    }

    function dropBall(bet) {
      const currentBalance = getBalance();
      if (bet > 0 && bet <= currentBalance) {
        updateBalance(-bet);
        const offset = Math.floor(Math.random() * 9) + 1;
        balls.push({
          x: canvas.width / 2 + (Math.random() < 0.5 ? -offset : offset),
          y: 0,
          vx: 0,
          vy: 0,
          bet: bet,
          active: true
        });
      }
    }

    function updateBalls() {
      const startX = canvas.width / 2 - ((SLOT_COUNT - 1) * pegSpacing) / 2;

      balls.forEach(ball => {
        if (!ball.active) return;

        ball.vy += gravity;
        ball.x += ball.vx;
        ball.y += ball.vy;

        pegs.forEach(p => {
          const dx = ball.x - p.x;
          const dy = ball.y - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < BALL_R + 5) {
            const angle = Math.atan2(dy, dx);
            const overlap = BALL_R + 5 - dist;
            ball.x += Math.cos(angle) * overlap;
            ball.y += Math.sin(angle) * overlap;
            ball.vx += Math.cos(angle) * 0.4;
            ball.vy = -Math.abs(ball.vy) * 0.3;
          }
        });

        if (ball.x < BALL_R || ball.x > canvas.width - BALL_R) {
          ball.vx *= -0.6;
          ball.x = Math.max(BALL_R, Math.min(canvas.width - BALL_R, ball.x));
        }

        if (ball.y > canvas.height - 40) {
          ball.active = false;
          const slot = Math.floor((ball.x - startX + pegSpacing / 2) / pegSpacing);
          const clamped = Math.max(0, Math.min(SLOT_COUNT - 1, slot));
          const multiplier = MULTIPLIERS[clamped];
          const payout = parseFloat((ball.bet * multiplier).toFixed(2));
          updateBalance(payout);
        }
      });

      balls = balls.filter(ball => ball.active);
    }

    function gameLoop() {
      updateBalls();
      drawBoard();
      requestAnimationFrame(gameLoop);
    }

    document.getElementById('dropBtn').onclick = () => {
      const bet = parseFloat(document.getElementById('betInput').value);
      dropBall(bet);
    };

    document.getElementById('backBtn').onclick = () => {
      window.location.href = 'index.html';
    };

    setupPegs();
    drawBoard();
    updateBalance(0);
    gameLoop();
  </script>
</body>
</html>